실습 환경 (택 1)
- Local 환경
    - Oracle XE와 SQL Developer 설치
    - 속도가 빠르며 Query 길이에 제한이 없음
    - 설치가 복잡함
- Cloud 환경
    - https://livesql.oracle.com
    - 설치가 필요 없으며 어디에서나 접속 가능
    - 속도가 느리며 Query 길이에 제한이 있음

DUAL
- 시스템이 제공해 주는 보이지 않는 테이블
- DUMMY라는 컬럼명 한 개에 'X'라는 데이터 하나가 들어있다.
- 예) SELECT 'ABC', 5+4
      FROM DUAL;
    - 출력: +---+------+-----+
           |   |'ABC' | 5+4 | 
           +---+------+-----+
           | 1 | ABC  | 9   | 
           +---+------+-----+

NULL 값
- ORACLE에서 NULL은 가장 큰 값으로 취급 됨 
    - MySQL, Microsoft의 sql server는 반대로 NULL을 가장 작은 값으로 취급
    - -> ORDER BY 컬럼명 ASC 했을 때 NULL값들은 가장 아래에 출력됨


타입 (data type): 숫자
    - 테이블의 타입 확인:
        - DESCRIBE 테이블명
        - 또는 DESC 테이블명
    - 숫자 NUMBER

ORACLE 연산자
    - 연산자 우선순위
        1. 괄호 ()
        2. NOT 연산자
        3. 비교 연산자, SQL 연산자
        4. AND
        5. OR
    - 산술 연산자
        - +, -, *, /, %(나머지)
        - number와 date 자료형에 적용 (MySQL에서는 날짜 시간에는 바로 적용 안 됨 )
        - date에 적용 시 날짜 값으로 적용됨 (23/01/29인 값에 +3 하면 23/02/01이 출력됨)
        - Null 값에 산술 연산의 결과는 항상 NULL
    - 비교 연산자
        - >, <, >=, <=, =
        - 모든 자료형에 적용 (문자열 크기는 사전순 - 먼저 나오는 것이 작음)
            - 예) '01' < '02' < '1' < '11' < '2'  
        - !=(같지 않음), <>(같지 않음), 
        - !< (왼쪽 값이 오른쪽 값보다 작지 않음)
        - !> (왼쪽 값이 오른쪽 값보다 크지 않음)
        - NULL에는 비교 연산자 사용 불가
    - 논리 연산자
        - 모든 자료형에 적용
        - NOT, AND, OR
        - 진리표
            - AND (*와 같은 개념)
                - 참 AND 참 = 참
                - 참 AND 거짓 = 거짓
                - 거짓 AND 참 = 거짓
                - 거짓 AND 거짓 = 거짓
                - 참 AND NULL = NULL
                - 거짓 AND NULL = 거짓
                - NULL AND NULL = NULL
            - OR (+와 같은 개념)
                - 참 OR 참 = 참
                - 참 OR 거짓 = 참
                - 거짓 OR 참 = 참
                - 거짓 OR 거짓 = 거짓
                - 참 OR NULL = 참
                - 거짓 OR NULL = NULL
                - NULL OR NULL = NULL
            - NOT
                - 참 = NOT 거짓
                - 거짓 = NOT 참
                - NULL = NOT NULL
    - SQL 연산자
        - 합성(연결) 연산자 - 문자열 결합  
            - || (파이프): str1 || str2
                - 2개 이상 가능: str1 || str2 || str3 || str4 ...
                    - 작동하는 방법: (((str1 || str2) || str3) || str4) ...
                - 예) str = 'a' || 'bcd'
                >> str = 'abcd'
            - CONCAT(str1, str2)
                - 2개만 연결 - 3개 이상 불가능
        - BETWEEN + AND, NOT BETWEEN + AND
            - 예) SELECT name FROM author WHERE id BETWEEN 1 AND 3
        - IN (list), NOT IN (list)
            - 예) SELECT name FROM author WHERE id IN (1, 2, 3)
            - 예) SELECT name AS "작가 이름"
                  FROM author
                  WHERE (id, name) IN ((1, '김%'), (2, '이%'));
        - IS NULL, IS NOT NULL
            - 주의: id = NUlL 또는 id <> NULL 할 시 에러가 난다 (이유: NULL은 비교 연산자 사용 불가)
        - LIKE
            - 문자열 비교 연산
            - 와일드카드 사용 가능 
                - '%' 임의의 문자 N개 / '_' 임의의 문자 1개 ('__'는 임의의 문자 2개, '___'는 임의의 문자 3개, and so on)


- DDL (Data Definition Lang) 데이터 정의어: 테이블/컬럼 정의/변경하는 명령어
    - CREATE TABLE 테이블명(필드이름1 필드타입1, 필드이름2 필드타입2, ...)
        - 테이블 생성
        - 예) CREATE TABLE author(id INT, name VARCHAR(10), email VARCHAR(20));
        - 생성 규칙:
            - 테이블명: 단수형 권장, 다른 테이블과 중복 불가
            - 컬럼명: 테이블 내 중복 불가, 생성시 각 컬럼들은 괄호 내에서 콤마로 구분, 칼럼 뒤에 데이터 유형 지정 필수
            - 예약어(reserved word) 사용 불가
            - 문자, 숫자, 일부 기호 (_, $, #)만 허용
            - 반드시 문자로 시작 가능 (숫자, 기호 불가)
            - 제약조건명: 다른 제약조건의 이름과 중복 불가
    - ALTER TABLE 테이블명
        - 수정 (TABLE 구성변경)
        - 테이블명 변경
            - ALTER TABLE 테이블명 RENAME 새로운테이블명;
            - 예) ALTER TABLE author RENAME member;
        - 컬럼명 변경
            - ALTER TABLE 테이블명 RENAME COLUMN 변경대상컬럼명 TO 새로운컬럼명;
            - 예) ALTER TABLE author RENAME COLUMN pw TO password;
        - 컬럼 추가
            - ALTER TABLE 테이블명 ADD COLUMN 새로운필드명 필드타입;
            - 예) ALTER TABLE author ADD COLUMN updated_at DATETIME;
        - 컬럼 옵션 덮어 붙여쓰기
            - ALTER TABLE 테이블명 MODIFY COLUMN 필드명 필드타입 추가옵션
            - 예) ALTER TABLE author MODIFY COLUMN created_at DATETIME DEFAULT CURRENT_TIMESTAMP;
        - 컬럼 삭제
            - ALTER TABLE 테이블명 DROP COLUMN 삭제할컬럼명;
    - DROP TABLE 테이블명
        - 삭제
    - RENAME
    - TRUNCATE
        - 테이블 안 모든 데이터를 한꺼번에 삭제
        - 문법: TRUNCATE TABLE 테이블명
        - 삭제 후 복구 불가능
        - DELETE보다 속도 더 빠름
- DML (Data Manipulation Lang) 데이터 조작어: 데이터 조회/추가/수정/삭제
    - SELECT 
        - 조회 - 조건이 없으면 모든 data 조회
        - 문법: SELECT [ALL/DISTINCT] 컬럼/필드명 FROM 테이블명 WHERE 조건
        - 컬럼/필드명을 명시해도 되고, * 을 통해 모든 컬럼 조회도 가능
        - * 
            - 테이블의 모든 데이터 출력
            - 예) SELECT * 
                    FROM author;
        - ALL
            - 중복 데이터 모두 출력 (default)
            - 문법: SELECT [ALL] 컬럼/필드명 FROM 테이블명
            - 예) SELECT [ALL] name, email 
                    FROM author;
        - DISTINCT 
            - 중복되는 값 제거
            - 문법: SELECT DISTINCT 컬럼명1 [, 컬럼명2, 컬럼명3 ...] FROM 테이블명;
            - DISTINCT 키워드는 SELECT 뒤와 첫 컬럼의 앞에 위치해야 함
            - NULL 값도 하나의 값으로 간주함
                - ORACLE에서 NULL값은 가장 큰 값으로 간주됨 -> ORDER BY 했을 때 가장 큰 값으로 간주됨
            - 예) SELECT DISTINCT name
                    FROM author;
                - 중복된 name들 제거되고 하나씩만 반환
            - 컬럼이 하나 이상인 경우 모든 컬름들의 조합을 출력
            - 예) SELECT DISTINCT name, email 
                    FROM author;
                - name과 email의 가능한 조합 반환
        - ROWNUM
            - TOP N개의 레코드를 반환
                - 상위 N개이므로 RONUM 뒤에는 =, >, >= 사용 불가; 다만, 1인 경우만 = 사용 가능
                    - 얘) SELECT 컬럼명
                          FROM 테이블명
                          WHERE ROWNUM = 1; --> 상위 1개 출력
                - 오로지 RONUM <= 숫자, RONUM < 숫자 만 사용 가능
            - 사용자가 아닌 시스템이 관리하는 Pseudo Column (i.e., 쓸 수는 있지만 진짜 컬럼은 아닌 컬럼)
            - 채번, 출력 개수 지정 등에 활용 가능
            - 예)SELECT 컬럼명
                 FROM 테이블명
                 WHERE ROWNUM <= 숫자;
            - 주의: 다른 database system들은 다른 키워드를 사용한다
                - SQL Server / MS Access:
                    - 문법: SELECT TOP 숫자 컬럼명
                            FROM 테이블명;
                    - percent도 가능: SELECT TOP 숫자 PERCENT 컬럼명
                                        FROM 테이블명;
                - MySQL:
                    - 믄밥: SELECT 컬럼명
                            FROM 테이블명
                            WHERE 조건
                            LIMIT 숫자;
                - Oracle 12:
                    - 문법: SELECT 컬럼명
                            FROM 테이블명
                            ORDER BY 컬럼명
                            FETCH FIRST 숫자 ROWS ONLY;
                    - percent도 가능: SELECT 컬럼명
                                        FROM 테이블명
                                        ORDER BY 컬럼명
                                        FETCH FIRST 숫자 PERCENT ROWS ONLY;
                - Older Oracle:
                    - 문법: SELECT 컬럼명
                            FROM 테이블명
                            WHERE ROWNUM <= 숫자;
                    - 문법 (with ORDER BY): SELECT 컬럼명
                                            FROM (SELECT 컬럼명 FROM 테이블명 ORDER BY 컬럼명)
                                            WHERE ROWNUM <= 숫자;
        - WHERE ~
            - 조건 걸기, 특정 조건을 만족하는 데이터 한정 출력
            - 문법: SELECT 컬럼명 FROM 테이블명 WHERE 조건
                - WHERE 컬럼명 (연산자) 컬럼값
            - 예) ... WHERE 컬럼명 = 컬럼값
        - ORDER BY
            - 선택한 결과의 정렬 (항상 조건 다 걸고 마지막에 붙임)
            - 문법: ORDER BY 컬럼명 [ASC/DESC]
            - SELECT 문으로 선택한 결과를 ORDER BY 절을 사용하여 정렬
            - 기본 설정은 ASC
            - 여러 컬럼의 데이터를 쉼표(,)를 사용하여 한 번에 정렬 가능
            - 예) SELECT * 
                    FROM author 
                    ORDER BY id DESC;
                - id를 기준으로 내림차순 정렬
            - 예) SELECT * 
                    FROM author 
                    ORDER BY name [ASC];
                - name을 기준으로 오름차순 정렬 [ASC]는 optional
            - 예) SELECT name, email
                    FROM author
                    ORDER BY 2;
                - 컬럼이 하나 이상일 경우 처음 컬럼부터 번호가 매겨진다 (name = 1, email = 2, ...)
                - ORDER BY 2에서 '2'는 SELECT 뒤 두번째로 명시된 컬럼인 'email'을 가리킨다
                - 그러므로 email을 기준으로 오름차순 정렬
            - ORDER BY절 생략시 PK를 기준으로 정렬하여 결과값 반환
            - ORDER BY절에는 SELECT절에 없는 컬럼도 사용 가능
            - 예) SELECT name 
                    FROM author 
                    ORDER BY email;
                - email을 기준으로 author 테이블의 name들이 오름차순 정렬로 출력
            - 예제) name만을 기준으로 오름차순 정렬
                - SELECT * FROM author ORDER BY name ASC;
            - 예제) name, email 기준으로 오름차순 정렬; name 중복일경우, email을 기준으로 정렬하게 되는 것
                - SELECT * FROM author ORDER BY name, email;
            - 예제) name은 오름차순, email은 내림차순으로 정렬
                - SELECT * FROM author ORDER BY name ASC, email DESC;
        - GROUP BY
            - 선택된 레코드의 집합을 툭정조건으로 그룹화한 결과 집합
            - 데이터의 값을 집계, 주로 집계 함수와 같이 사용
            - 집계 함수 예) SUM(), COUNT(), AVG(), MIN(), MAX() 등
            - 예) 작가가 쓴 글의 갯수를 알아보기; 이름, 이메일, 글 쓴 갯수 출력
                - SELECT a.name AS author_name, a.email, 
                            COUNT(p.author_id) AS 'post_count' 
                    FROM author a 
                    LEFT JOIN post p ON a.id = p.author_id 
                    GROUP BY a.email;
            - 예) sales테이블에서 지점별(지점ID) 평균매출 구하기
                - SELECT branch_id, AVG(amount) AS average 
                    FROM sales 
                    GROUP BY branch_id;
        - GROUP BY + HAVING 조건절
            - 구문 전체에 대한 조건절은 WHERE ~ 이고 그룹화된 데이터에 대한 조건절은 HAVING ~
            - 예) author에서 중복되는 이름과 중복되는 횟수 조회
                - SELECT name, COUNT(*) AS COUNT 
                    FROM author 
                    GROUP BY name 
                    HAVING COUNT(*) > 1;
            - 예) 2022년 한해동안 지점별 총매출을 구하라. 정렬은 금액 내림차순. 총매출이 2000 이상인 지점만 출력. 출력 - 지점명, 총매출액
                - SELECT b.name, SUM(s.amount)
                    FROM branches AS b 
                    INNER JOIN sales AS s 
                    ON b.id = s.branch_id 
                    WHERE s.created_date >= '2022-01-01' 
                    AND s.created_date < '2023-01-01' 
                    GROUP BY b.name 
                    HAVING SUM(s.amount) >= 2000.00;
        - AS
            - 테이블과 필드에 임시로 별칭(alias)을 부여하고, 해당 별칭을 SELECT문에서 사용
            - AS 라는 키워드를 줘서 별칭(alias)를 이용한 처리 
            - 문법: SELECT 컬럼명 [AS] 별칭 FROM 테이블이름;
            - 생략 가능
            - 예) SELECT COUNT(DISTINCT name) AS count_name 
                    FROM author;
            - 예) SELECT COUNT(DISTINCT name) count_name 
                    FROM author;
            - 출력되는 별칭은 WHERE, FROM, GROUP BY, HAVING, ORDER BY 뒤에는 사용하지 않는다; 임시로 부여한 것이기 때문에 명령어 안에서는 사용되지 않는다
            - 별칭이 공백, 특수문자 등 포함 시 큰 따옴표("") 사용
                - 공백이나 특수문자 포함 안해도 "" 사용해도 됨
            - 예) SELECT name AS "작가 이름",
                            date AS "날짜!"
                            content AS "내용"
                    FROM author
    - INSERT INTO 
        - 테이블 한 건의 레코드 추가
            - 문법1: INSERT INTO 테이블명 (필드명1, 필드명2, 필드명3 ...) VALUES (데이터값1, 데이터값2, 데이터값3 ...);  -> 필드타입 넣을 필요 없음
                - 예) INSERT INTO author(id, name, email) values (1, 'leo', 'leo@gmail.com');
                - 컬럼 순서는 실제 테이블의 컬럼 순서와 무관
                - 정의하지 않은 컬럼은 NULL이 입력됨
            - 문법2: INSERT INTO 테이블명 VALUES (전체 컬럼의 value_list)
                - 예) INSERT INTO Pearl VALUES (13, 'merona', 'binggrae', 'melon', 600)
                - 전체 컬럼의 모든 값을 순서대로 입력해야 됨
                - 빈 값은 NULL 로 입력
                    - 주의: MySQL에서는 안 되지만 ORACLE에서는 NULL 또는 작은 따옴표 ('')로 입력 가능 (**주의: 작은 따옴표 안에 공백이 있으면 안 됨 - 예) ' '는 하나의 공백 값으로 인식)
        - 여러 건 입력 시 INSERT ALL ~
            - 언제 사용?
                - 테이블 생성 후 초기 데이터 일괄 업로드
                    - 문법: INSERT ALL
                                    INTO 테이블명 VALUES (전체 컬럼의 value_list)
                            SELECT * FROM DUAL;
                - 기존 테이블의 레코드 조회 후 다른 테이블에 삽입 (예, 회원 명단 조회해서 그 중 미납 회원을 뽑아서 별도의 미납자 테이블 생성)
                    - 문법: INSERT ALL
                                    INTO 테이블2 VALUES (컬럼1, 컬럼2, ...)
                                    INTO 테이블3 VALUES (컬럼1, 컬럼3, ...)
                            SELECT 컬럼1, 컬럼2, 컬럼3 FROM 테이블1
                        - 테이블1에서 레코드를 반환하여 테이블2, 테이블3에 분할 저장
            - 반드시 SELECT 구문도 함께 사용해야 됨 (SELECT 없을 시 에러 남)
        - 문자 또는 날짜 값은 작은 따옴표로 묶음 (숫자 데이터는 작은 따옴표 없이 사용)
    - UPDATE 
        - 데이터 수정
        - 문법: UPDATE 테이블명 SET 필드명1 = 수정값1, 필드명2 = 수정값2 [WHERE 필드명 = 데이터값];
        - 조건이 없으면 다 바꿈 (조심해야 함)
        - 예) UPDATE author 
              SET email = 'pearl.ahn@gmail.com' 
              WHERE id = '2';
            - author 테이블의 id가 '2'인 레코드의 email을 'pearl.ahn@gmail.com'으로 바꿈
        - 예) UPDATE author
              SET email IS NULL
            - author 테이블의 모든 레코드의 email을 NULL값으로 바꿈
        - UPDATE와 ROWNUM을 이용한 채번
            - 테이블 내의 UNIQUE한 일련번호를 생성하는 경우
            - 1단계: ROWNUM을 담을 새 컬럼을 만든다
                - 예) ALTER TABLE 테이블명 ADD (새컬럽명 NUMBER);
                      ALTER TABLE Pearl ADD (ROW_ID NUMBER)
                    - 'Pearl'이라는 테이블에 'ROW_ID'의 이름을 가지고 NUMBER라는 타입을 가진 빈 컬럼 추가
            - 2단계: 해당 컬럼에 ROWNUM값을 준다
                - 예) UPDATE 테이블명 SET 새컬럼명 = ROWNUM;
                      UPDATE Pearl SET ROW_ID = ROWNUM;
                    - 'ROW_ID'라는 컬럼에 해당 레코드의 ROWNUM 값으로 수정
    - DELETE
        - 데이터 삭제 (테이블에 존재하는 전체 레코드 삭제)
        - 문법: DELETE [FROM] 테이블명 [WHERE 필드명 = 데이터값];
            - DELETE 테이블명; 또는 DELETE FROM 테이블명
            - 주의: MySQL에서는 꼭 FROM을 써줘야 된다 -> DELETE FROM ~
        - 한 row 전체를 지우기 때문에 컬럼명이나 *를 지정해줄 필요 없다
        - 삭제 후 복구 가능 (TRUNCATE는 복구 불가)
        - 조건을 빼버리면 테이블 전체를 지움 (조심해야 됨)
        - 예) DELETE FROM author 
                WHERE id >= 10;
- DCL (Data Control Lang) 데이터 제어어: 사용자 권한 관리 (계정 생성 후 권한부여)
    - GRANT (권한 부여)
    - REVOKE (권한 취소)
- + TCL (Transaction Control Lan) 트랜젝션 제어어: 변경 내용을 확정/취소
    - COMMIT
    - ROLLBACK
